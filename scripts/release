#!/usr/bin/env python3
import os
import sys
import subprocess
from pathlib import Path

BOLD = '\033[1m'
END = '\033[0m'


def run(cmd: str, cwd: Path, capture=True) -> str:
    if capture:
        return subprocess.check_output(cmd, cwd=cwd, text=True, shell=True).strip()
    else:
        subprocess.check_call(cmd, cwd=cwd, shell=True)
        return ""


def discover_packages(repo_path: Path):
    return [
        d
        for d in os.listdir(repo_path)
        if os.path.isdir(d) and d.startswith("plain") and not d.endswith(".egg-info")
    ]


def get_commits_since_version_change(repo_path: Path, package_path: Path):
    pyproject_path = package_path / "pyproject.toml"
    rel_pyproject = pyproject_path.relative_to(repo_path)
    log_cmd = f'git log --format="%H" -- {rel_pyproject}'
    commits = run(log_cmd, repo_path).split("\n")

    last_version_commit = None
    current_version = None

    for commit in commits:
        # Check if this commit actually changed the version line
        diff_cmd = f'git show --no-merges --format="" {commit} -- {rel_pyproject}'
        diff_output = run(diff_cmd, repo_path)

        # Look for actual changes to the version line (+ or - prefix)
        version_changed = False
        for line in diff_output.splitlines():
            if (line.startswith('+') or line.startswith('-')) and 'version' in line and '=' in line:
                version_changed = True
                break

        if version_changed:
            last_version_commit = commit
            break

    if last_version_commit is None:
        last_version_commit = commits[-1] if commits else None

    if not last_version_commit:
        return []

    log_cmd = (
        f'git log --format="%H %s" {last_version_commit}..HEAD -- '
        f'{package_path.relative_to(repo_path)} ":(exclude){package_path.relative_to(repo_path)}/tests"'
    )
    lines = run(log_cmd, repo_path).split("\n")
    return [line.split(" ", 1) for line in lines if line]


def bump_version_with_uv(package_path: Path, bump_type: str) -> str:
    """Bump the version using uv version --bump and return the new version."""
    # Run uv version --bump in the package directory
    run(f"uv version --bump {bump_type}", package_path, capture=False)
    # Return the new version
    return get_current_version(package_path)


def get_current_version(package_path: Path) -> str:
    """Get the current version using uv version --short."""
    return run("uv version --short", package_path)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--force", action="store_true", help="Ignore dirty git status")
    # Skip running the local pre-commit script and any git commit hooks. Mirrors `git commit -n`.
    parser.add_argument(
        "-n",
        "--no-verify",
        action="store_true",
        help="Skip running pre-commit checks before releasing",
    )
    parser.add_argument("packages", nargs="*", help="Packages to release")
    args = parser.parse_args()

    repo_path = Path.cwd()
    if not args.force:
        status = run("git status --porcelain", repo_path)
        if status:
            print("Error: git status not clean -- commit or stash changes, or use --force")
            sys.exit(1)

    # Optionally run pre-commit before starting the release process unless the
    # caller has requested to skip verification.
    if not args.no_verify:
        subprocess.check_call(["./scripts/pre-commit"], cwd=repo_path)

    packages = args.packages if args.packages else discover_packages(repo_path)

    # Phase 1: Collect version bump choices
    release_plan = []
    for package in packages:
        pkg_path = repo_path / package
        commits = get_commits_since_version_change(repo_path, pkg_path)
        print()
        if commits:
            print(f"{BOLD}Commits for {package}:{END}")
            for h, s in commits:
                print(f"{h[:7]} - {s}")
        else:
            print(f"{package}: No changes since last version change. Skipping.")
            continue

        while True:
            choice = input("\nRelease type (major/minor/patch/skip) [skip]: ").strip()
            if not choice:
                choice = "skip"
            if choice in ["major", "minor", "patch", "skip"]:
                break
            print("Invalid choice. Please enter major, minor, patch, or skip.")

        if choice == "skip":
            continue

        release_plan.append({
            "package": package,
            "path": pkg_path,
            "bump_type": choice,
        })

    if not release_plan:
        print("\nNo packages to release.")
        sys.exit(0)

    # Phase 2: Bump versions
    print(f"\n{BOLD}Bumping versions...{END}")
    for item in release_plan:
        package = item["package"]
        pkg_path = item["path"]
        bump_type = item["bump_type"]

        old_version = get_current_version(pkg_path)
        new_version = bump_version_with_uv(pkg_path, bump_type)
        item["old_version"] = old_version
        item["new_version"] = new_version
        print(f"{package}: {old_version} → {new_version}")

    # Phase 3: Generate release notes in parallel
    print(f"\n{BOLD}Generating release notes in parallel...{END}")
    processes = []
    for item in release_plan:
        package = item["package"]
        new_version = item["new_version"]
        proc = subprocess.Popen(
            ["./scripts/generate-release-notes", package, new_version],
            cwd=repo_path
        )
        processes.append((package, proc))

    # Wait for all processes to complete
    for package, proc in processes:
        print(f"Generating release notes for {package}...")
        proc.wait()
        if proc.returncode != 0:
            print(f"Error generating release notes for {package}")
            sys.exit(1)
        print(f"✓ {package}")

    # Phase 4: Run sync and fix once after all changes
    print(f"\n{BOLD}Running uv sync and formatting...{END}")
    run("uv sync", repo_path, capture=False)
    subprocess.check_call(["./scripts/fix"], cwd=repo_path)

    # Phase 5: Commit each package individually
    print(f"\n{BOLD}Ready to commit releases...{END}")
    for item in release_plan:
        package = item["package"]
        pkg_path = item["path"]
        new_version = item["new_version"]

        print(f"\n{BOLD}{package} {new_version}{END}")

        # Show the diff of changes for this package
        print("\nChanges for this release:")
        diff_output = run(
            f"git diff --color=always {pkg_path / 'pyproject.toml'} {pkg_path / '**' / 'CHANGELOG.md'}",
            repo_path
        )
        if diff_output:
            print(diff_output)

        confirm = input("\nCommit this release? (y/n) [y]: ").strip()
        if not confirm:
            confirm = "y"
        if confirm.lower() != "y":
            print("Skipping.")
            continue

        run(f"git add {pkg_path / 'pyproject.toml'} {pkg_path / '**' / 'CHANGELOG.md'} uv.lock", repo_path, capture=False)
        run(
            f"git commit -m 'Release {package} {new_version}' -n", repo_path, capture=False
        )
        run(
            f"git tag -a '{package}@{new_version}' -m 'Release {package} {new_version}'",
            repo_path,
            capture=False,
        )
        print(f"Committed {package} {new_version}")

    # Push all changes
    confirm = input("Push all changes? (y/n): ")
    if confirm.lower() == "y":
        run("git push --follow-tags", repo_path, capture=False)
        print("Changes pushed successfully.")


if __name__ == "__main__":
    main()
