#!/usr/bin/env python3
import os
import sys
import subprocess
from pathlib import Path

BOLD = '\033[1m'
END = '\033[0m'


def run(cmd: str, cwd: Path, capture=True) -> str:
    if capture:
        return subprocess.check_output(cmd, cwd=cwd, text=True, shell=True).strip()
    else:
        subprocess.check_call(cmd, cwd=cwd, shell=True)
        return ""


def discover_packages(repo_path: Path):
    return [
        d
        for d in os.listdir(repo_path)
        if os.path.isdir(d) and d.startswith("plain") and not d.endswith(".egg-info")
    ]


def get_commits_since_version_change(repo_path: Path, package_path: Path):
    pyproject_path = package_path / "pyproject.toml"
    rel_pyproject = pyproject_path.relative_to(repo_path)
    log_cmd = f'git log --format="%H" -- {rel_pyproject}'
    commits = run(log_cmd, repo_path).split("\n")

    last_version_commit = None
    current_version = None

    for commit in commits:
        # Check if this commit actually changed the version line
        diff_cmd = f'git show --no-merges --format="" {commit} -- {rel_pyproject}'
        diff_output = run(diff_cmd, repo_path)

        # Look for actual changes to the version line (+ or - prefix)
        version_changed = False
        for line in diff_output.splitlines():
            if (line.startswith('+') or line.startswith('-')) and 'version' in line and '=' in line:
                version_changed = True
                break

        if version_changed:
            last_version_commit = commit
            break

    if last_version_commit is None:
        last_version_commit = commits[-1] if commits else None

    if not last_version_commit:
        return []

    log_cmd = (
        f'git log --format="%H %s" {last_version_commit}..HEAD -- '
        f'{package_path.relative_to(repo_path)} ":(exclude){package_path.relative_to(repo_path)}/tests"'
    )
    lines = run(log_cmd, repo_path).split("\n")
    return [line.split(" ", 1) for line in lines if line]


def bump_version_with_uv(package_path: Path, bump_type: str) -> str:
    """Bump the version using uv version --bump and return the new version."""
    # Run uv version --bump in the package directory
    run(f"uv version --bump {bump_type}", package_path, capture=False)
    # Return the new version
    return get_current_version(package_path)


def get_current_version(package_path: Path) -> str:
    """Get the current version using uv version --short."""
    return run("uv version --short", package_path)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--force", action="store_true", help="Ignore dirty git status")
    # Skip running the local pre-commit script and any git commit hooks. Mirrors `git commit -n`.
    parser.add_argument(
        "-n",
        "--no-verify",
        action="store_true",
        help="Skip running pre-commit checks before releasing",
    )
    parser.add_argument("packages", nargs="*", help="Packages to release")
    args = parser.parse_args()

    repo_path = Path.cwd()
    if not args.force:
        status = run("git status --porcelain", repo_path)
        if status:
            print("Error: git status not clean -- commit or stash changes, or use --force")
            sys.exit(1)

    # Optionally run pre-commit before starting the release process unless the
    # caller has requested to skip verification.
    if not args.no_verify:
        subprocess.check_call(["./scripts/pre-commit"], cwd=repo_path)

    packages = args.packages if args.packages else discover_packages(repo_path)

    for package in packages:
        pkg_path = repo_path / package
        commits = get_commits_since_version_change(repo_path, pkg_path)
        print()
        if commits:
            print(f"{BOLD}Commits for {package}:{END}")
            for h, s in commits:
                print(f"{h[:7]} - {s}")
        else:
            print(f"{package}: No changes since last version change. Skipping.")
            continue

        while True:
            choice = input("\nRelease type (major/minor/patch/skip) [skip]: ").strip()
            if not choice:
                choice = "skip"
            if choice in ["major", "minor", "patch", "skip"]:
                break
            print("Invalid choice. Please enter major, minor, patch, or skip.")

        if choice == "skip":
            continue

        old_version = get_current_version(pkg_path)
        new_version = bump_version_with_uv(pkg_path, choice)
        run("uv sync", repo_path)

        # Need to update the changelog here so it's in the commit
        print("Generating release notes...")
        subprocess.check_call(["./scripts/generate-release-notes", package, new_version])

        # Ask if they are ready to commit
        confirm = input("Are you ready to commit? (y/n): ")
        if confirm.lower() != "y":
            print("Aborting release.")
            continue

        subprocess.check_call(["./scripts/fix"], cwd=repo_path)

        run(f"git add {pkg_path / 'pyproject.toml'} {pkg_path / '**' / 'CHANGELOG.md'} uv.lock", repo_path, capture=False)
        run(
            f"git commit -m 'Release {package} {new_version}' -n", repo_path, capture=False
        )
        run(
            f"git tag -a '{package}@{new_version}' -m 'Release {package} {new_version}'",
            repo_path,
            capture=False,
        )
        print(f"Released {package} {new_version}")

    # Push all changes
    confirm = input("Push all changes? (y/n): ")
    if confirm.lower() == "y":
        run("git push --follow-tags", repo_path, capture=False)
        print("Changes pushed successfully.")


if __name__ == "__main__":
    main()
