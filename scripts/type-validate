#!/usr/bin/env python3
"""
Validate type annotations for directories that should have 100% coverage.

This script ensures that once a directory reaches 100% type annotation coverage,
it stays at 100% to prevent backwards regressions.
"""

import sys
import subprocess
import json
import re
import argparse
from pathlib import Path

# ANSI color codes
class Colors:
    GREEN = "\033[32m"
    RED = "\033[31m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    DIM = "\033[2m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

# Paths (files or directories) that must maintain 100% type annotation coverage
FULLY_TYPED_PATHS = [
    # Fully typed packages
    "plain",
    "plain-admin",
    "plain-api",
    "plain-auth",
    "plain-cache",
    "plain-code",
    "plain-dev",
    "plain-elements",
    "plain-email",
    "plain-esbuild",
    "plain-flags",
    "plain-htmx",
    "plain-loginlink",
    "plain-oauth",
    "plain-pages",
    "plain-pageviews",
    "plain-passwords",
    "plain-pytest",
    "plain-redirection",
    "plain-sessions",
    "plain-observer",
    "plain-support",
    "plain-tailwind",
    "plain-toolbar",
    "plain-tunnel",
    "plain-vendor",
    "plain-jobs",
    "plain-models",
    "plain-scan",
    "plain-start",
]

# Paths that should pass type checking but don't require 100% coverage
TYPE_CHECK_ONLY_PATHS = [
    "example/app",
]


def check_type_coverage(path: str) -> tuple[float, int, int, int, int, int]:
    """Check type coverage for a file or directory.

    Returns:
        Tuple of (coverage_percentage, fully_typed_functions, total_functions,
                  ignore_comments, cast_calls, assert_statements)
    """
    # Run from example directory since plain code requires a Plain app context
    # Use relative path from example to the target
    relative_path = f"../{path}"
    result = subprocess.run(
        ["uv", "run", "plain", "code", "annotations", relative_path, "--json"],
        capture_output=True,
        text=True,
        cwd="example",
    )

    if result.returncode != 0:
        print(f"Error checking coverage for {path}:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        return 0.0, 0, 0, 0, 0, 0

    data = json.loads(result.stdout)
    return (
        data["overall_coverage"],
        data["fully_typed_functions"],
        data["total_functions"],
        data.get("total_ignores", 0),
        data.get("total_casts", 0),
        data.get("total_asserts", 0),
    )


def run_type_check(path: str, verbose: bool = False) -> tuple[bool, int]:
    """Run type checker on a file or directory.

    Returns:
        Tuple of (passed, error_count)
    """
    result = subprocess.run(
        ["./scripts/type-check", path],
        capture_output=True,
        text=True,
    )

    # Count diagnostics from output
    # ty check outputs "Found X diagnostics" at the end, or individual "error[...]:" lines
    error_count = 0
    output = result.stdout + result.stderr

    # First try to find the summary line "Found X diagnostics"
    if match := re.search(r'Found (\d+) diagnostics?', output):
        error_count = int(match.group(1))
    else:
        # Fall back to counting individual error lines
        # ty check formats errors as "error[error-type]: message"
        for line in output.split('\n'):
            if re.match(r'^\s*error\[', line):
                error_count += 1

    passed = result.returncode == 0

    # Print verbose output if requested and there are any diagnostics
    if verbose and error_count > 0:
        print(f"\n{Colors.DIM}{'─' * 80}")
        print(f"Type check output for {path}:")
        print(f"{'─' * 80}{Colors.RESET}")
        print(output)
        print(f"{Colors.DIM}{'─' * 80}{Colors.RESET}\n")

    return passed, error_count


def main(details: bool = False):
    """Main entry point."""
    print(f"{Colors.BOLD}Validating type annotations for fully typed paths...{Colors.RESET}")
    print()

    failed_items = []
    total_errors = 0
    total_ignores = 0
    total_casts = 0
    total_asserts = 0
    passed_count = 0
    failed_count = 0

    for path in FULLY_TYPED_PATHS:
        path_obj = Path(path)
        if not path_obj.exists():
            print(f"{Colors.YELLOW}⚠️  {path} does not exist, skipping{Colors.RESET}")
            continue

        # Check coverage
        coverage, typed, total, ignores, casts, asserts = check_type_coverage(path)
        total_ignores += ignores
        total_casts += casts
        total_asserts += asserts
        coverage_color = Colors.GREEN if coverage == 100.0 else Colors.RED
        coverage_status = f"{coverage_color}✓{Colors.RESET}" if coverage == 100.0 else f"{Colors.RED}✗{Colors.RESET}"

        # Run type checker
        type_check_passed, error_count = run_type_check(path, verbose=details)
        type_check_color = Colors.GREEN if type_check_passed else Colors.RED
        type_check_status = f"{type_check_color}✓{Colors.RESET}" if type_check_passed else f"{Colors.RED}✗{Colors.RESET}"
        total_errors += error_count

        # Track pass/fail
        if coverage == 100.0 and type_check_passed:
            passed_count += 1
        else:
            failed_count += 1

        # Print all paths in both modes (verbose adds ty check output)
        error_info = f" {Colors.DIM}({error_count} errors){Colors.RESET}" if error_count > 0 else ""
        smell_parts = []
        if ignores > 0:
            smell_parts.append(f"{ignores} ignores")
        if casts > 0:
            smell_parts.append(f"{casts} casts")
        if asserts > 0:
            smell_parts.append(f"{asserts} asserts")
        smell_info = f" {Colors.DIM}({', '.join(smell_parts)}){Colors.RESET}" if smell_parts else ""
        coverage_info = f"{Colors.DIM}Coverage: {coverage:.1f}% ({typed}/{total}){Colors.RESET}"
        print(f"{coverage_status} {type_check_status} {path} - {coverage_info}{error_info}{smell_info}")

        # Track failures
        if coverage < 100.0:
            failed_items.append((path, f"coverage {coverage:.1f}%"))
        if not type_check_passed:
            failed_items.append((path, f"type check failed ({error_count} errors)"))

    # Type-check-only paths
    if TYPE_CHECK_ONLY_PATHS:
        print()
        print(f"{Colors.BOLD}Validating type checking for type-check-only paths...{Colors.RESET}")
        print()

        for path in TYPE_CHECK_ONLY_PATHS:
            path_obj = Path(path)
            if not path_obj.exists():
                print(f"{Colors.YELLOW}⚠️  {path} does not exist, skipping{Colors.RESET}")
                continue

            # Run type checker only
            type_check_passed, error_count = run_type_check(path, verbose=details)
            type_check_color = Colors.GREEN if type_check_passed else Colors.RED
            type_check_status = f"{type_check_color}✓{Colors.RESET}" if type_check_passed else f"{Colors.RED}✗{Colors.RESET}"
            total_errors += error_count

            # Track pass/fail
            if type_check_passed:
                passed_count += 1
            else:
                failed_count += 1

            # Print all paths (verbose adds ty check output)
            error_info = f" {Colors.DIM}({error_count} errors){Colors.RESET}" if error_count > 0 else ""
            print(f"{type_check_status} {path}{error_info}")

            # Track failures
            if not type_check_passed:
                failed_items.append((path, f"type check failed ({error_count} errors)"))

    # Print summary
    total_count = passed_count + failed_count
    print()
    print(f"{Colors.BOLD}Type Validation Summary{Colors.RESET}")
    print(f"  {Colors.GREEN}Passed:{Colors.RESET} {passed_count}/{total_count}")
    if failed_count > 0:
        print(f"  {Colors.RED}Failed:{Colors.RESET} {failed_count}/{total_count}")
    if total_ignores > 0:
        print(f"  {Colors.YELLOW}Type ignores:{Colors.RESET} {total_ignores}")
    if total_casts > 0:
        print(f"  {Colors.YELLOW}cast() calls:{Colors.RESET} {total_casts}")
    if total_asserts > 0:
        print(f"  {Colors.YELLOW}assert statements:{Colors.RESET} {total_asserts}")

    if failed_items:
        print()
        print(f"{Colors.RED}{Colors.BOLD}❌ Type validation failed{Colors.RESET}")
        print()
        for path, reason in failed_items:
            print(f"  {Colors.RED}•{Colors.RESET} {path}: {Colors.DIM}{reason}{Colors.RESET}")
        print()
        print(f"{Colors.BOLD}Total diagnostics/errors: {Colors.RED}{total_errors}{Colors.RESET}")
        print()
        print(f"{Colors.DIM}To fix:{Colors.RESET}")
        print(f"{Colors.DIM}  1. Check coverage: uv run plain code annotations <path> --details{Colors.RESET}")
        print(f"{Colors.DIM}  2. Add missing annotations{Colors.RESET}")
        print(f"{Colors.DIM}  3. Run type check: ./scripts/type-check <path>{Colors.RESET}")
        print(f"{Colors.DIM}  4. Format: ./scripts/fix{Colors.RESET}")
        sys.exit(1)

    print()
    if total_errors > 0:
        print(f"{Colors.YELLOW}⚠️  All paths passed validation, but found {total_errors} total diagnostics/errors{Colors.RESET}")
    else:
        print(f"{Colors.GREEN}{Colors.BOLD}✓ All paths passed type validation with no errors{Colors.RESET}")
    sys.exit(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Validate type annotations for fully typed paths"
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Show all paths and detailed type check output (default: only show failures and summary)",
    )
    args = parser.parse_args()

    main(details=args.verbose)
