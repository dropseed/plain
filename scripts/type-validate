#!/usr/bin/env python3
"""
Validate type annotations for directories that should have 100% coverage.

This script ensures that once a directory reaches 100% type annotation coverage,
it stays at 100% to prevent backwards regressions.
"""

import sys
import subprocess
import json
from pathlib import Path

# Paths (files or directories) that must maintain 100% type annotation coverage
FULLY_TYPED_PATHS = [
    # Fully typed packages
    "plain",
    "plain-admin",
    "plain-api",
    "plain-auth",
    "plain-cache",
    "plain-code",
    "plain-dev",
    "plain-elements",
    "plain-email",
    "plain-esbuild",
    "plain-flags",
    "plain-htmx",
    "plain-loginlink",
    "plain-oauth",
    "plain-pages",
    "plain-pageviews",
    "plain-passwords",
    "plain-pytest",
    "plain-redirection",
    "plain-sessions",
    "plain-observer",
    "plain-support",
    "plain-toolbar",
    "plain-tunnel",
    "plain-vendor",
    "plain-worker",
    # plain-models: Fully typed directories
    "plain-models/plain/models/functions",
    # plain-models: Fully typed individual files
    "plain-models/plain/models/aggregates.py",
    "plain-models/plain/models/backups/cli.py",
    "plain-models/plain/models/backups/clients.py",
    "plain-models/plain/models/backups/core.py",
    "plain-models/plain/models/base.py",
    "plain-models/plain/models/backends/base/base.py",
    "plain-models/plain/models/backends/base/client.py",
    "plain-models/plain/models/backends/base/introspection.py",
    "plain-models/plain/models/backends/base/validation.py",
    "plain-models/plain/models/backends/ddl_references.py",
    "plain-models/plain/models/backends/utils.py",
    "plain-models/plain/models/backends/mysql/client.py",
    "plain-models/plain/models/backends/mysql/compiler.py",
    "plain-models/plain/models/backends/mysql/creation.py",
    "plain-models/plain/models/backends/mysql/validation.py",
    "plain-models/plain/models/backends/postgresql/client.py",
    "plain-models/plain/models/backends/postgresql/creation.py",
    "plain-models/plain/models/backends/sqlite3/client.py",
    "plain-models/plain/models/backends/sqlite3/creation.py",
    "plain-models/plain/models/backends/sqlite3/features.py",
    "plain-models/plain/models/config.py",
    "plain-models/plain/models/connections.py",
    "plain-models/plain/models/constants.py",
    "plain-models/plain/models/constraints.py",
    "plain-models/plain/models/database_url.py",
    "plain-models/plain/models/db.py",
    "plain-models/plain/models/deletion.py",
    "plain-models/plain/models/entrypoints.py",
    "plain-models/plain/models/enums.py",
    "plain-models/plain/models/exceptions.py",
    "plain-models/plain/models/fields/json.py",
    "plain-models/plain/models/fields/mixins.py",
    "plain-models/plain/models/fields/related.py",
    "plain-models/plain/models/fields/related_descriptors.py",
    "plain-models/plain/models/fields/related_lookups.py",
    "plain-models/plain/models/fields/related_managers.py",
    "plain-models/plain/models/fields/reverse_related.py",
    "plain-models/plain/models/forms.py",
    "plain-models/plain/models/indexes.py",
    "plain-models/plain/models/lookups.py",
    "plain-models/plain/models/migrations/exceptions.py",
    "plain-models/plain/models/migrations/executor.py",
    "plain-models/plain/models/migrations/migration.py",
    "plain-models/plain/models/migrations/operations/base.py",
    "plain-models/plain/models/migrations/operations/fields.py",
    "plain-models/plain/models/migrations/operations/special.py",
    "plain-models/plain/models/migrations/optimizer.py",
    "plain-models/plain/models/migrations/questioner.py",
    "plain-models/plain/models/migrations/recorder.py",
    "plain-models/plain/models/migrations/serializer.py",
    "plain-models/plain/models/migrations/utils.py",
    "plain-models/plain/models/migrations/writer.py",
    "plain-models/plain/models/options.py",
    "plain-models/plain/models/otel.py",
    "plain-models/plain/models/preflight.py",
    "plain-models/plain/models/query_utils.py",
    "plain-models/plain/models/registry.py",
    "plain-models/plain/models/sql/compiler.py",
    "plain-models/plain/models/sql/datastructures.py",
    "plain-models/plain/models/sql/subqueries.py",
    "plain-models/plain/models/sql/where.py",
    "plain-models/plain/models/test/pytest.py",
    "plain-models/plain/models/test/utils.py",
    "plain-models/plain/models/transaction.py",
    "plain-models/plain/models/utils.py",
]


def check_type_coverage(path: str) -> tuple[float, int, int]:
    """Check type coverage for a file or directory."""
    result = subprocess.run(
        ["./scripts/type-coverage", path, "--json"],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Error checking coverage for {path}:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        return 0.0, 0, 0

    data = json.loads(result.stdout)
    return (
        data["overall_coverage"],
        data["fully_typed_functions"],
        data["total_functions"],
    )


def run_type_check(path: str) -> bool:
    """Run type checker on a file or directory."""
    result = subprocess.run(
        ["./scripts/type-check", path],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Type check failed for {path}:", file=sys.stderr)
        print(result.stdout, file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        return False

    return True


def main():
    """Main entry point."""
    print("Validating type annotations for fully typed paths...")
    print()

    failed_items = []

    for path in FULLY_TYPED_PATHS:
        path_obj = Path(path)
        if not path_obj.exists():
            print(f"⚠️  {path} does not exist, skipping")
            continue

        # Check coverage
        coverage, typed, total = check_type_coverage(path)
        coverage_status = "✓" if coverage == 100.0 else "✗"

        # Run type checker
        type_check_passed = run_type_check(path)
        type_check_status = "✓" if type_check_passed else "✗"

        # Print single line
        print(f"{coverage_status} {type_check_status} {path} - Coverage: {coverage:.1f}% ({typed}/{total})")

        # Track failures
        if coverage < 100.0:
            failed_items.append((path, f"coverage {coverage:.1f}%"))
        if not type_check_passed:
            failed_items.append((path, "type check failed"))

    if failed_items:
        print("❌ Type validation failed for the following paths:")
        for path, reason in failed_items:
            print(f"  - {path}: {reason}")
        print()
        print("To fix:")
        print("  1. Check coverage: ./scripts/type-coverage <path> --details --missing")
        print("  2. Add missing annotations")
        print("  3. Run type check: ./scripts/type-check <path>")
        print("  4. Format: ./scripts/fix")
        sys.exit(1)

    print("✓ All paths passed type validation")
    sys.exit(0)


if __name__ == "__main__":
    main()
