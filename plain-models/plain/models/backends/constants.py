"""
PostgreSQL-specific constants for data types, operators, and lookup patterns.

These are static mappings that don't depend on connection state.
"""

from __future__ import annotations

from typing import Any


def _get_varchar_column(data: dict[str, Any]) -> str:
    if data["max_length"] is None:
        return "varchar"
    return "varchar({max_length})".format(**data)


# Maps Field objects to their associated PostgreSQL column types.
# Column-type strings can contain format strings interpolated against Field.__dict__.
DATA_TYPES: dict[str, Any] = {
    "PrimaryKeyField": "bigint",
    "BinaryField": "bytea",
    "BooleanField": "boolean",
    "CharField": _get_varchar_column,
    "DateField": "date",
    "DateTimeField": "timestamp with time zone",
    "DecimalField": "numeric(%(max_digits)s, %(decimal_places)s)",
    "DurationField": "interval",
    "FloatField": "double precision",
    "IntegerField": "integer",
    "BigIntegerField": "bigint",
    "GenericIPAddressField": "inet",
    "JSONField": "jsonb",
    "PositiveBigIntegerField": "bigint",
    "PositiveIntegerField": "integer",
    "PositiveSmallIntegerField": "smallint",
    "SmallIntegerField": "smallint",
    "TextField": "text",
    "TimeField": "time",
    "UUIDField": "uuid",
}

# Check constraints for fields that need them.
DATA_TYPE_CHECK_CONSTRAINTS: dict[str, str] = {
    "PositiveBigIntegerField": '"%(column)s" >= 0',
    "PositiveIntegerField": '"%(column)s" >= 0',
    "PositiveSmallIntegerField": '"%(column)s" >= 0',
}

# Suffix applied to column definitions (e.g., for identity columns).
DATA_TYPES_SUFFIX: dict[str, str] = {
    "PrimaryKeyField": "GENERATED BY DEFAULT AS IDENTITY",
}

# SQL operators for lookups.
OPERATORS: dict[str, str] = {
    "exact": "= %s",
    "iexact": "= UPPER(%s)",
    "contains": "LIKE %s",
    "icontains": "LIKE UPPER(%s)",
    "regex": "~ %s",
    "iregex": "~* %s",
    "gt": "> %s",
    "gte": ">= %s",
    "lt": "< %s",
    "lte": "<= %s",
    "startswith": "LIKE %s",
    "endswith": "LIKE %s",
    "istartswith": "LIKE UPPER(%s)",
    "iendswith": "LIKE UPPER(%s)",
}

# SQL pattern for escaping special characters in LIKE clauses.
# Used when the right-hand side isn't a raw string (e.g., an expression).
PATTERN_ESC = (
    r"REPLACE(REPLACE(REPLACE({}, E'\\', E'\\\\'), E'%%', E'\\%%'), E'_', E'\\_')"
)

# Pattern operators for non-literal LIKE lookups.
PATTERN_OPS: dict[str, str] = {
    "contains": "LIKE '%%' || {} || '%%'",
    "icontains": "LIKE '%%' || UPPER({}) || '%%'",
    "startswith": "LIKE {} || '%%'",
    "istartswith": "LIKE UPPER({}) || '%%'",
    "endswith": "LIKE '%%' || {}",
    "iendswith": "LIKE '%%' || UPPER({})",
}
